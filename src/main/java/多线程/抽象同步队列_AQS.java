package 多线程;

public class 抽象同步队列_AQS {
}
/**
 *      AQS 全名 AbstractQueueSynchronized 同步抽象队列
 *      通常静态内部类sync继承他 然后分为公平锁和非公平锁
 *      也就是 FairSync 和 NonfairSync
 *      内部原理 维护了一个FIFO的队列 双向链表
 *      三个主要变量
 *          head
 *          tail
 *          state volatile变量
 *     头结点 尾节点 状态值
 *     大致上就是：
 *      先判断状态值 表示能获取锁 那么利用cas修改state值
 *      之后 再进来的线程不能获取锁 则会保存这个线程的信息
 *      包装成node插入AQS维护的队列尾部，当前面的线程释放锁
 *      就会唤醒头节点。
 *     NonfairSync的加锁过程
 *          1.尝试修改状态值
 *              成功 保存当前占用锁的线程是谁
 *              不成功 走流程2
 *          2.调用获取方法
 *              首先尝试获取 1
 *                  获取成功
 *              不成功调用 先把当前线程包装成一个Node
 *              添加到队列里面，然后一个死循环 只有当
 *              节点变成头结点的时候，才会去尝试取锁
 *              以上任意一种成功 将线程中断
 *     NonfairSync的解锁过程
 *          1.清空状态值 唤醒后续节点
 *     Fair加锁过程
 *          就一行代码 acquire（1） 不尝试抢锁 就是按照队列的节点顺序走
 *     Fair解锁过程 同上
 *
 *
 *
 * */